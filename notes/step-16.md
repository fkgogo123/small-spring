实现功能：通过三级缓存解决循环依赖。
核心思想：通过工厂对象来提前暴露对象，通过三级缓存的结构来存储不同时期的对象。

三级缓存分别存储的是什么?
成品对象、半成品对象、工厂对象。

必须使用三级缓存吗？可以使用二级或一级缓存吗？
其实使用二级缓存或一级缓存都能解决，只是需要注意一下几点：
①如果只使用一级缓存处理，则流程无法拆分，复杂度也会增加，同时半成品对象可能会产生空指针异常。如果将半成品与成品对象分开，
则处理起来更加美观、简介且易扩展。
②Spring的两大特性除了IOC还有AOP，即基于字节码增强后的方法。三级缓存最主要解决的循环依赖是对AOP的处理。
如果将AOP代理对象的创建提前，则使用二级缓存也可以解决。但是，这就违背了Spring创建对象的原则——Spring首先
将所有的普通 bean 对象初始化完成，再处理代理对象的初始化。

bean的生命周期：
实例化-依赖注入-初始化-AOP-注入单例池-销毁。

A依赖B，B依赖A，且B需要被AOP代理。循环依赖解决流程如下：
A对象实例化，存放工厂对象到三级缓存【提前暴露】，依赖注入B。【0,0，Factory-A】
getSingleton(B)查找不到，开始创建对象。
B对象实例化，存放工厂对象到三级缓存【提前暴露】，依赖注入A。【0,0，Factory-A、Factory-B】
getSingleton(A)查找对象A，从三级缓存取出A目标对象，放到二级缓存，并删除三级缓存。【0，early-A, Factory-B】
B初始化完成，得到成品对象后：
①getSingleton(B)查找对象B，从三级缓存取出B代理对象，放到二级缓存，并删除三级缓存。【0，early-A、early-Proxy-B，0】
②registrySingleton(B),将代理对象B放入一级缓存，并删除二级缓存。【Proxy-B，early-A,0】

给A对象注入B属性，此时的B是一个代理对象B，A初始化完成，得到成品对象B后：
①getSingleton(A)查找对象A，从二级缓存取出A目标对象。
②registerSingleton(A),将目标对象A放入一级缓存，并删除二级缓存。【A、Proxy-B，0,0】


提前暴露：创建一个工厂对象放入三级缓存。
三级缓存工厂既可以创建目标对象，也可以创建代理对象。从三级缓存中getObject获取对象时，会去判断该对象是否需要被代理，据此返回目标对象或代理对象。

此前的AOP对象代理会在初始化过程中判断对象是否需要被代理。采用三级缓存后，代理对象统一由三级缓存产生。






